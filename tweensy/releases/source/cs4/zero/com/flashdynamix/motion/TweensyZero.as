/**.______                                                   ________                              __         ___     /\__  _\                                                 /\_____  \                           /'__`\     /'___`\   \/_/\ \/ __  __  __     __     __    ___     ____  __  __\/____//'/'     __   _ __   ___     /\ \/\ \   /\_\ /\ \  ...\ \ \/\ \/\ \/\ \  /'__`\ /'__`\/' _ `\  /',__\/\ \/\ \    //'/'    /'__`\/\`'__\/ __`\   \ \ \ \ \  \/_/// /__ ....\ \ \ \ \_/ \_/ \/\  __//\  __//\ \/\ \/\__, `\ \ \_\ \  //'/'___ /\  __/\ \ \//\ \L\ \   \ \ \_\ \__  // /_\ \.....\ \_\ \___x___/'\ \____\ \____\ \_\ \_\/\____/\/`____ \ /\_______\ \____\\ \_\\ \____/    \ \____/\_\/\______/......\/_/\/__//__/   \/____/\/____/\/_/\/_/\/___/  `/___/> \\/_______/\/____/ \/_/ \/___/      \/___/\/_/\/_____/ ......................................................./\___/                                                      .......................................................\/__/....... Same great tween taste with 0 calories! .............................................................. */package com.flashdynamix.motion {	import flash.display.DisplayObject;
	import flash.display.MovieClip;
	import flash.display.Sprite;
	import flash.events.Event;
	import flash.filters.BitmapFilter;
	import flash.geom.ColorTransform;
	import flash.geom.Matrix;
	import flash.media.SoundChannel;
	import flash.media.SoundTransform;
	import flash.utils.Dictionary;
	import flash.utils.getTimer;	
	/**	 * TweensyZero is a lightweight tweening engine designed specifically for developers who want to achieve small files sizes	 * but are not too fused about overall performance. Though TweensyZero is still quite effecient the original Tweensy class delivers the best tweening performance.<BR><BR>	 * The TweensyZero Class contains a collection of tweens specified by property tweens for an Object instance. The TweensyZero code library weighs about 2.9KB once compiled<BR>	 * <BR><BR>	 * A tween can be executed in one of the following manners:	 * <ul>	 * <li>to - allows for defining where the animation is going 'to' from its current position<BR>	 * e.g. <code>Tweensy.to(item, {x:50, y:100});</code>	 * </li>	 * <li>from - allows for defining where the animation is coming 'from' and will be going to its current position<BR>	 * e.g. <code>Tweensy.from(item, {x:200, y:150});</code>	 * </li>	 * <li>fromTo - allows for defining where the animation is coming 'from' and going 'to'<BR>	 * e.g. <code>Tweensy.fromTo(item, {x:200, y:150}, {x:50, y:100});</code>	 * </li>	 * </ul>	 */	public class TweensyZero {
		public static const version : Number = 0.2;		/**		 * Sets the refreshType to use the current frames per second of the SWF allowing for time based animations.		 * 		 * @see com.flashdynamix.motion.TweensyZero#refreshType		 */		public static const TIME : String = "time";		/**		 * Sets the refreshType to use the current seconds per frame on each ENTER_FRAME allowing for frame based animations.		 * 		 * @see com.flashdynamix.motion.TweensyZero#refreshType		 */		public static const FRAME : String = "frame";		/**		 * The default tween which will be used when none is provided using a to, from and fromTo method.		 * 		 * @see com.flashdynamix.motion.TweensyTimelineZero#ease TweensyTimelineZero.ease		 */		public static var defaultTween : Function = easeOut;		/**		 * Executed on each frame update.		 * 		 * @see com.flashdynamix.motion.TweensyZero#onUpdateParams		 */		public static var onUpdate : Function;		/**		 * Parameters applied to the onUpdate Function.		 * 		 * @see com.flashdynamix.motion.TweensyZero#onUpdate		 */		public static var onUpdateParams : Array;		/**		 * Executed when all tweens are complete.		 * 		 * @see com.flashdynamix.motion.TweensyZero#onComplete		 */		public static var onComplete : Function;		/**		 * Parameters applied to the onComplete Function.		 * 		 * @see com.flashdynamix.motion.TweensyZero#onCompleteParams		 */		public static var onCompleteParams : Array;		/**		 * Defines whether the TweensyGroup Class will automatically resolve property tween conflicts.<BR>		 * Property tween conflicts occur when one property tweens time overlaps another.		 */		public static var lazyMode : Boolean = true;
		private static var _secondsPerFrame : Number = 1 / 30;		private static var frame : Sprite = new Sprite();		private static var time : int = 0;		private static var _refreshType : String = "time";		private static var _paused : Boolean = false;		private static var list : Array = [];		private static var filterDictionary : Dictionary = new Dictionary(true);
		/**		 * Adds a to based tween using the properties defined in the target Object.		 * 		 * @param instance The instance Object to be tweened or multiple instances if using the type Array e.g. [item1, item2]		 * @param to An Object containing the properties you would like to tween to e.g. {x:50, y:25}		 * or this can be relative e.g. {x:'50', y:'-25'} or can be a random position e.g. {x:'-50, 50', y:'-25, 25'}		 * @param duration The time in secs you would like the tween to run.		 * @param ease The ease equation you would like to use e.g. Quintic.easeOut.		 * @param delayStart The delay you would like to use at the beginning of the tween and every subsequent REPLAY of a tween.		 * @param update This param is used when tweening a property in an Object which needs to be applied onto another Object each time		 * the tween occurs.<BR>		 * For example to(new DropShadowFilter(), {alpha:0}, myDisplayItem); Will apply the tweening DropShadowFilter onto the DisplayObject 'myDisplayItem'.		 * @param onComplete The onComplete event handler you would like to fire once the tween is complete.		 * @param onCompleteParams The params applied to the onComplete handler.		 * 		 * @return An instance to the TweensyTimelineZero which can used to manage this tween.		 * 		 * @see com.flashdynamix.motion.TweensyTimelineZero		 */		public static function to(instance : Object, to : Object, duration : Number = 0.5, ease : Function = null, delayStart : Number = 0, update : Object = null, onComplete : Function = null, onCompleteParams : Array = null) : TweensyTimelineZero {			if(!hasTimelines) startUpdate();						var timeline : TweensyTimelineZero = setup(instance, duration, ease, delayStart, onComplete, onCompleteParams, update);						for(var propName:String in to) {				timeline.to[propName] = translate(instance[propName], to[propName]);				timeline.properties++;			}						add(timeline);						return timeline;		}
		/**		 * Adds a from based tween using the properties defined in the from Object.		 * 		 * @param instance The instance Object to be tweened or multiple instances if using the type Array e.g. [item1, item2]		 * @param from An Object containing the properties you would like to tween from e.g. {x:50, y:25}		 * or this can be relative e.g. {x:'50', y:'-25'} or can be a random position e.g. {x:'-50, 50', y:'-25, 25'}		 * @param duration The time in secs you would like the tween to run.		 * @param ease The ease equation you would like to use e.g. Quintic.easeOut.		 * @param delayStart The delay you would like to use at the beginning of the tween and every subsequent REPLAY of a tween.		 * @param update This param is used when tweening a property in a Object which needs to be applied onto another Object each time		 * the tween occurs.<BR>		 * For example to(new DropShadowFilter(), {alpha:0}, myDisplayItem); Will apply the tweening DropShadowFilter onto the DisplayObject 'myDisplayItem'.		 * @param onComplete The onComplete event handler you would like to fire once the tween is complete.		 * @param onCompleteParams The params applied to the onComplete handler.		 * 		 * @return An instance to the TweensyTimelineZero which can used to manage this tween.		 * 		 * @see com.flashdynamix.motion.TweensyTimelineZero		 */		public static function from(instance : Object, from : Object, duration : Number = 0.5, ease : Function = null, delayStart : Number = 0, update : Object = null, onComplete : Function = null, onCompleteParams : Array = null) : TweensyTimelineZero {			if(!hasTimelines) startUpdate();						var timeline : TweensyTimelineZero = setup(instance, duration, ease, delayStart, onComplete, onCompleteParams, update);						for(var propName:String in from) {				timeline.to[propName] = instance[propName];				instance[propName] = translate(instance[propName], from[propName]);				timeline.properties++;			}						add(timeline);						return timeline;		}
		/**		 * Adds a from to based tween using the properties defined in the from and to Objects.		 * 		 * @param instance The instance Object to be tweened or multiple instances if using the type Array e.g. [item1, item2]		 * @param from An Object containing the properties you would like to tween from e.g. {x:50, y:25}		 * or this can be relative e.g. {x:'50', y:'-25'} or can be a random position e.g. {x:'-50, 50', y:'-25, 25'}		 * @param to An Object containing the properties you would like to tween to e.g. {x:50, y:25}		 * or this can be relative e.g. {x:'50', y:'-25'} or can be a random position e.g. {x:'-50, 50', y:'-25, 25'}		 * @param duration The time in secs you would like the tween to run		 * @param ease The ease equation you would like to use e.g. Quintic.easeOut		 * @param delayStart The delay you would like to use at the beginning of the tween and every subsequent REPLAY of a tween		 * @param update This param is used when tweening a property in a Object which needs to be applied onto another Object each time		 * the tween occurs.<BR>		 * For example to(new DropShadowFilter(), {alpha:0}, myDisplayItem); Will apply the tweening DropShadowFilter onto the DisplayObject 'myDisplayItem'		 * @param onComplete The onComplete event handler you would like to fire once the tween is complete.		 * @param onCompleteParams The params applied to the onComplete handler.		 * 		 * @return An instance to the TweensyTimelineZero which can used to manage this tween.		 * 		 * @see com.flashdynamix.motion.TweensyTimelineZero		 */		public static function fromTo(instance : Object, from : Object, to : Object, duration : Number = 0.5, ease : Function = null, delayStart : Number = 0, update : Object = null, onComplete : Function = null, onCompleteParams : Array = null) : TweensyTimelineZero {			if(!hasTimelines) startUpdate();						var timeline : TweensyTimelineZero = setup(instance, duration, ease, delayStart, onComplete, onCompleteParams, update);						for(var propName:String in to) {				timeline.to[propName] = translate(instance[propName], to[propName]);				instance[propName] = translate(instance[propName], from[propName]);				timeline.properties++;			}						add(timeline);						return timeline;		}
		private static function add(item : TweensyTimelineZero) : void {						if(lazyMode) {				var i : int = 0;				var len : int = list.length;				var timelineB : TweensyTimelineZero;				var totalDuration : Number;							for(i = len - 1;i >= 0; i--) {					timelineB = list[i];									totalDuration = timelineB.delayStart + timelineB.duration + timelineB.delayEnd;									if(timelineB.key == item.key && item.delayStart < (totalDuration - timelineB.time)) {						for(var propName:String in item.to) {							delete timelineB.to[propName];							delete timelineB.from[propName];							timelineB.properties--;						}											if(timelineB.properties == 0) list.splice(i, 1);					}				}			}						list.push(item);		}
		private static function setup(instance : Object, duration : Number, ease : Function, delayStart : Number, onComplete : Function, onCompleteParams : Array, update : Object) : TweensyTimelineZero {						var timeline : TweensyTimelineZero = new TweensyTimelineZero();			timeline.instance = instance;			timeline.duration = duration;			timeline.ease = (ease != null) ? ease : defaultTween;			timeline.delayStart = delayStart;			timeline.update = update;			timeline.onComplete = onComplete;			timeline.onCompleteParams = onCompleteParams;			timeline.key = (update != null) ? update : instance;						if(instance is BitmapFilter && update != null) {				var filterList : Array = filterDictionary[update];							if(filterList == null || filterList.length != DisplayObject(update).filters.length) {					filterList = filterDictionary[update] = DisplayObject(update).filters;				}							if(filterList.indexOf(instance) == -1) filterList.push(instance);								DisplayObject(update).filters = filterList;			}						return timeline;		}
		/**		 * Allows for removing tweens which have been executed by the TweensyZero Class. <BR>		 * Tweens can be stopped via an instance or tween props by the following methods :		 * <ul>		 * <li>stop(instance); - stops all property tweens for this instance.</li>		 * <li>stop(instance, "x", "y"); - stops all x,y property tweens for this instance.</li>		 * <li>stop([instance1, instance2]); - stops all property tweens for these instances.</li>		 * <li>stop([instance1, instance2], "x", "y"); - stops all x,y property tweens for these instances.</li>		 * <li>stop(null, "x", "y"); - stops all x,y property tweens.</li>		 * <li>stop(); - stops all tweens, although it is recommeded to use the stopAll method as this is more efficient.</li>		 * </ul>		 * 		 */		public static function stop(instance : * = null, ...props : Array) : void {			var items : Array = (instance is Array) ? instance : (instance == null) ? null : [instance];			var timeline : TweensyTimelineZero;						for(var i : int = items.length - 1;i >= 0; i--) {								timeline = list[i];								if(items == null || items.indexOf(timeline.key) != -1) {										if(props.length == 0) {						list.splice(i, 1);					} else {												for(var propName:String in timeline.to) {							if(props.indexOf(propName) != -1) {								delete timeline.to[propName];								delete timeline.from[propName];								timeline.properties--;							}						}												if(timeline.properties == 0) list.splice(i, 1);					}				}			}						if(list.length == 0) stopUpdate();		}
		/**		 * Stops all tweens which have been executed by the TweensyZero Class.		 */		public static function stopAll() : void {			list.length = 0;						stopUpdate();		}
		/**		 * Pauses all tweens which have been executed by the TweensyZero Class.		 */		public static function pause() : void {			if(_paused) return;						_paused = true;						stopUpdate();		}
		/**		 * Resumes all tweens which have been executed by the TweensyZero Class.		 */		public static function resume() : void {			if(!_paused) return;						_paused = false;						startUpdate();		}
		/**		 * Whether the TweensyZero Class is currently paused.		 */		public static function get paused() : Boolean {			return _paused;		}
		public static function set secondsPerFrame(spf : Number) : void {			_secondsPerFrame = spf;		}
		/**		 * Sets how many seconds per frame are added to to each on an ENTER_FRAME when TweensyZero Class's refreshType is of the TweensyZero.FRAME mode.<BR>		 * This property and feature is intended as an alternative to the TweensyZero.TIME (time based animation) mode which can result in jumpy effects.		 * Instead TweensyZero.FRAME ensures that every frame is rendered in the duration of your animation.		 * e.g. If your FLA frame rate is 30 frames per second then set secondsPerFrame to 1 second for every 30 frames (1/30).		 * 		 * @see com.flashdynamix.motion.TweensyZero#refreshType		 * @see com.flashdynamix.motion.TweensyZero#FRAME 		 */		public static function get secondsPerFrame() : Number {			return _secondsPerFrame;		}
		public static function set refreshType(type : String) : void {			_refreshType = type;		}
		/**		 * Sets the timing system currently in use by the TweensyZero Class.<BR>		 * @param type Can be either :		 * <ul>		 * <li>TweensyZero.TIME</li>		 * <li>TweensyZero.FRAME</li>		 * </ul>		 * @see com.flashdynamix.motion.TweensyZero#FRAME 	 		 * @see com.flashdynamix.motion.TweensyZero#TIME		 * @see com.flashdynamix.motion.TweensyZero#secondsPerFrame		 */		public static function get refreshType() : String {			return _refreshType;		}
		/**		 * Total number of animations in progress for the TweensyZero class.		 */		public static function get timelines() : int {			return list.length;		}
		/**		 * Whether the TweensyZero Class has any timeline animations.		 */		public static function get hasTimelines() : Boolean {			return (timelines > 0);		}
		private static function update(event : Event) : void {			var dif : Number;						if(refreshType == TIME) {				dif = getTimer() - time;				time += dif;				dif *= 0.001;			}						var i : int = 0;			var len : int = list.length;			var timeline : TweensyTimelineZero;			var args : Array;						for(i = len - 1;i >= 0; i--) {				timeline = list[i];								timeline.time += dif;								if(timeline.time > timeline.delayStart) {										var currentTime : Number = timeline.time - timeline.delayStart;					currentTime = (currentTime > timeline.duration) ? timeline.duration : currentTime;					var finished : Boolean = (currentTime >= timeline.duration + timeline.delayEnd);										args = [currentTime, 0, 1, timeline.duration].concat(timeline.easeParams);										var position : Number = timeline.ease.apply(null, args);					var q : Number = 1 - position;										for(var propName:String in timeline.to) {												if(timeline.from[propName] == null) timeline.from[propName] = timeline.instance[propName];												var value : Number = timeline.from[propName] * q + timeline.to[propName] * position;												if(propName == "currentFrame") {							MovieClip(timeline.instance).gotoAndStop(int(value));						} 						else {							timeline.instance[propName] = value;						}					}										if(timeline.update != null) {						if(timeline.instance is ColorTransform) {							DisplayObject(timeline.update).transform.colorTransform = timeline.instance;						} 						else if (timeline.instance is Matrix) {							DisplayObject(timeline.update).transform.matrix = timeline.instance;						} 						else if (timeline.instance is SoundTransform) {
							if(timeline.update is SoundChannel) {								SoundChannel(timeline.update).soundTransform = timeline.instance;
							} else {								Sprite(timeline.update).soundTransform = timeline.instance;							}						} 						else if (timeline.instance is BitmapFilter) {							DisplayObject(timeline.update).filters = filterDictionary[timeline.update];						}					}										if(timeline.onUpdate != null) timeline.onUpdate.apply(null, timeline.onUpdateParams);										if(finished) {						if(timeline.onComplete != null) timeline.onComplete.apply(null, timeline.onCompleteParams);												list.splice(i, 1);					}				}			}						if(onUpdate != null) onUpdate.apply(null, onUpdateParams);						if(!hasTimelines) {				stopUpdate();				if(onComplete != null) onComplete.apply(null, onCompleteParams);			}		}
		private static function easeOut(t : Number, b : Number, c : Number, d : Number) : Number {			return c * ((t = t / d - 1) * t * t * t * t + 1) + b;		}
		private static function startUpdate() : void {			time = getTimer();						frame.addEventListener(Event.ENTER_FRAME, update, false, 0, true);		}
		private static function stopUpdate() : void {			frame.removeEventListener(Event.ENTER_FRAME, update);		}
		private static function translate(current : Number, value : *) : Number {						var target : Number;						if(value is String) {				var values : Array = String(value).split(",");				if(values.length == 1) {					target = current + parseFloat(value);				} else {					var start : Number = parseFloat(values[0]), end : Number = parseFloat(values[1]);					target = current + start + (Math.random() * (end - start));				}			} else {				target = value;			}						return target;		}
		public function toString() : String {			return "TweensyZero " + version + " {timelines:" + timelines + "}";		}	}}